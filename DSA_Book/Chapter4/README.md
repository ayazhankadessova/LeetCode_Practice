| Exercise  | Problem | Approach | Solution | Day | 
| ------------- | ------------- | ------------- | ------------- | ------------- | 
| ![#c5f015](https://placehold.co/15x15/c5f015/c5f015.png) 4.10  | Write a program that lists all files in a directory and their sizes.<br/>Mimic the routine in the online code. | Approach: <br/>1. Start listing with depth 0 <br/>2. Add spaces for depth;<br/>Print name of current file-><br/>if dir:dir+name;<br/>if file:fileName+length <br/>3. check current file is directory itself:<br/>if dir->repeat same for every file in dir. | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/FileSystem.java) | Feb, 24 |
| x. All file names  | Get all file names in a directory & subdirectory | Approach:<br/>1. push directory to stack<br/>2. While not empty -> pop<br/> if what we pop is file -> print; <br/>if what we pop is directory -> push all files in dir in stack;<br/>3.continue doing same w them | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/Allfiles.java) | Feb, 24 |
| 4.11  | BST with Insert, Delete, Find min | Approach:<br/>1. Insert BST checking for right/left.<br/>2. Delete based on cases: <br/>1) no children -> null; <br/>2) right/left child -> assign either. 3) 2 children -> get smallest from right subtree| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/BinarySearchTree.java) | Feb, 25 |
| 4.20-25  | AVL Tree Generic Implementation | AVLTree class is a self-balancing binary search tree that extends the Tree interface.<br/>1. Node class has two children (left and right) and stores data of a generic type T, a height attribute that is used to balance the AVLTree.<br/>2. AVLTree class includes methods to insert, delete, and search for nodes in the tree. <br/>3. Insert & Delete are same as in BST + updatHeigh and applyrotation to keep balance every operation.<br/>4. balance determines which rotation to apply: L, R, RL, LR.<br/>5. height of a node in the AVLTree is defined as the maximum height of its children plus one.| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/AVLTree.java) | Feb, 26 |
| L103  | Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).| Aproach: <br/>1. Add root to the queue. <br/>2. While queue is not empty, poll and add right and left children to the queue -> now the queue has right and left of the previous node. <br/>3. Repeat the process while queue is not empty. <br/>4. For every level, reverse/dont reverse alternatively. 4. Add every level to result list.| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/BinaryTree/BinaryTreeZigzag.java) | Feb, 27 |
| ![#1589F0](https://placehold.co/15x15/1589F0/1589F0.png) L105 | Construct Binary Tree from Preorder and Inorder Traversal. Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.| Approach: 1. Get root -> first in preorder  <br/>2. Find left and right subtree thanx to root's index in inorder -> root divides -> Right ST \ root \ Left ST <br/>3. Count number of elements in left and right -> Get length of right ST & left ST -> tells how to partition pre-order traversal.<br/>4. Make new pre-order & inorder for Left ST & Right ST -> *first is root, remove 1 from preorder. dont add m in inorder.<br/>5. For left pre-order/inorder -> make them params of current function & assign to left -- do same with right.<br/>6. Repeat the process while either array length == 0.| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/BST_From_InOrder_PreOrder/BST_InPre.java) | March, 1 | 
| ![#c5f015](https://placehold.co/15x15/c5f015/c5f015.png) L106  | Construct Binary Tree from Inorder and Postorder Traversal. Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.| Approach (same logic as L106): <br/>1. Last element of preorder is always root<br/>2. Use index or root to partition inorder & postorder array into left and right subtrees recursively.| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter4/BST_From_InOrder_PreOrder/BST_PostPre.java) | March, 3 | 
| ![#1589F0](https://placehold.co/15x15/1589F0/1589F0.png) x | Construct B-Tree w/ Search | Approach:  </br>1. Starting from the root node, compare k with the first key of the node: If k = the first key of the node,return the node and the index. </br> 2. If k.leaf=true,return NULL (i.e. not found). </br> 3. If k < the first key of the root node, search the left child of this key recursively. </br> 4. If there is more than one key in the current node and k > the first key, compare k with the next key in the node. If k < next key, search the left child of this key (ie. k lies in between the first and the second keys). Else, search the right child of the key. </br> 5. Repeat steps 1 to 4 until the leaf is reached.| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/tree/main/DSA_Book/Chapter4/BTree/BTree.java) | March, 5 | 
| ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)  x | Construct B-Tree w/ Insertion | Approach:  </br>1. If the tree is empty, allocate a root node and insert the key. </br>2. Update the allowed number of keys in the node. </br>3. Search the appropriate node for insertion.If the node is full, follow the steps below.- Insert the elements in increasing order.Now,there are elements greater than its limit. - So, split at the median. - Push the median key upwards and make the left keys as a left child and theright keys as a right child. If the node is not full, follow the steps below.Insert the node in increasing order.| [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/tree/main/DSA_Book/Chapter4/BTree/BTree.java) | March, 6 | 

- ![#c5f015](https://placehold.co/15x15/c5f015/c5f015.png) `Easy`
- ![#1589F0](https://placehold.co/15x15/1589F0/1589F0.png) `Medium`
- ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png) `Hard`


- Resources 
1. Binary Search Tree: https://youtu.be/81PpYQ0AN_w / https://www.youtube.com/watch?v=YBw5JRZK9_g
2. AVL Tree: https://youtu.be/Jj9Mit24CWk
3. AVL Tree rotations: https://youtu.be/vRwi_UcZGjU
4. Binary Tree from PreOrder & InOrder Traversal: https://leetcode.com/problems/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/editorial/
5. B-Tree: https://www.programiz.com/dsa/b-tree , https://www.youtube.com/watch?v=SI6E4Ma2ddg
