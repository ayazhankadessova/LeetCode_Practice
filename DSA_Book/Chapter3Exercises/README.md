| Exercise  | Problem | Approach | Solution | Day |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 3.1  | You are given a list, L, and another list, P, containing integers sorted in ascending order. <br />The operation printLots(L,P) will print the elements in L that are in positions specified by P. <br />For instance, if P = 1, 3, 4, 6, the elements in positions 1, 3, 4, and 6 in L are printed.<br /> Write the procedure printLots(L,P). <br />You may use only the public Collections API container operations. What is the running time of your procedure?  | Content Cell  | Content Cell  | x |
| 3.2  | Swap two given nodes of a linked list | 1. if x and y are the same -> no change <br /> 2. Search for X, keep track of prevX and currX <br /> 3. Search for X, keep track of prevX and currX <br /> 4. Check if either x or y don't exist <br /> 5. If x not head -> prevX.next = currY. If head -> Y <br /> 6. Same for y <br /> 7. Swap next pointers  | Content Cell  | x |
| 3.2  | Find Intersection  | 1. Initialize iterators for two lists <br /> 2. Get the first element of the list <br /> 3. While both of the items is not null, iterate through the list and compare values<br />4. If values are the same, add them to the Result list <br />5. If compareTo returns negative, value1 is less, and there is no chance to meet it in the sort array, so advance iter1 <br />6. If compareTo return positive, value1 is more, we can still meet it in list2, so advance iter2 <br />7. When advancing check if we can advance with hasNext. If no next -> return null and while loop will stop <br />8. Iter through result list  | Content Cell  | x |
| 3.5  | Find Union | Given two sorted lists, L1 and L2, write a procedure to compute L1 âˆª L2 using only the basic list operations. <br />1. Initialize iterators for two lists <br />2. Get the first element of the list <br />3. While at least of the elements are not null, continue. - different from intersection because union means all the elems in both, no duplicates tho <br />4. if one of the elements is null, get everything from the other list - eg: elem1 is null -> collect all elements that are left in list2 <br />5. if both are not null: compare them - if elem1 is smaller -> advance it, because we will not meet it again and there is no danger we will add it twice - if elem1 is bigger -> advance iter2, because there is a change that we meet elem1 duplicate is list2 later 6. Iterate through res  | Content Cell  | Feb, 14 |
| 3.6 | Josephus Problem (remove with skips)  | 1. Create a Doubly Linked List <br />2. Start with head, iterate while only one element is left <br />3. skip specified number of times <br />4. If while skipping we reach a tail, then we start from the head.next <br />5. Delete element -> reassign next/prev 6. When only one element is left, then return head.next  | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/JosephusIterableList.java)  | Feb, 15 |
| 3.9/3.10  | Collections addAll() and removeAll()  | 1. Given iterable items list, get the iterator and add while hasNext() / <br />1. Given iterable items list, get the iterator and check everything in the specified collection <br />2. Get the iterator for original list and iterate through it to check if this elements exists there too. If yes, remove it from the original collection.  | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/ArrayListTest.java)| Feb, 15 |
| 3.11 | Singly Linked List with a <br /> head node only  | 1. Initilize head <br />2. Initialize head.next <br />3. Contains: iter with while and check <br />4. add: check if contains, if not, create p and p.next = head.next; head.next = p; add in the middle <br />5. remove: check if contains. <br />**Do tracing** node and current node. When found node to remove -> prev.next = current.next  | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/SLL_headeronly.java)  | Feb, 16  |
| 3.12 | Content Cell  | Same as 3.11, but (4) add function changed to: <br /> 4. To keep sorted , check if it is more than header.next.  <br />* If yes, insert as usual: p.next = header.next; header.next = p; <br />* If no, start iterating from header to end, while remembering the previous node until we find a node which is more than one we want to insert.<br />* Make new node point to where previous node pointed. <br />* Make previous node point to new node. | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/SLL_headeronly_sorted.java)  |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |


