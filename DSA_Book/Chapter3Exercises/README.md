| Exercise  | Problem | Approach | Solution | Day |
| ------------- | ------------- | ------------- | ------------- | ------------- |
| 3.1  | You are given a list, L, and another list, P, containing integers sorted in ascending order. <br />The operation printLots(L,P) will print the elements in L that are in positions specified by P. <br />For instance, if P = 1, 3, 4, 6, the elements in positions 1, 3, 4, and 6 in L are printed.<br /> Write the procedure printLots(L,P). <br />You may use only the public Collections API container operations. What is the running time of your procedure?  | Content Cell  | Content Cell  | x |
| 3.2  | Swap two given nodes of a linked list | 1. if x and y are the same -> no change <br /> 2. Search for X, keep track of prevX and currX <br /> 3. Search for X, keep track of prevX and currX <br /> 4. Check if either x or y don't exist <br /> 5. If x not head -> prevX.next = currY. If head -> Y <br /> 6. Same for y <br /> 7. Swap next pointers  | Content Cell  | x |
| 3.2  | Find Intersection  | 1. Initialize iterators for two lists <br /> 2. Get the first element of the list <br /> 3. While both of the items is not null, iterate through the list and compare values<br />4. If values are the same, add them to the Result list <br />5. If compareTo returns negative, value1 is less, and there is no chance to meet it in the sort array, so advance iter1 <br />6. If compareTo return positive, value1 is more, we can still meet it in list2, so advance iter2 <br />7. When advancing check if we can advance with hasNext. If no next -> return null and while loop will stop <br />8. Iter through result list  | Content Cell  | x |
| 3.5  | Find Union | Given two sorted lists, L1 and L2, write a procedure to compute L1 âˆª L2 using only the basic list operations. <br />1. Initialize iterators for two lists <br />2. Get the first element of the list <br />3. While at least of the elements are not null, continue. - different from intersection because union means all the elems in both, no duplicates tho <br />4. if one of the elements is null, get everything from the other list - eg: elem1 is null -> collect all elements that are left in list2 <br />5. if both are not null: compare them - if elem1 is smaller -> advance it, because we will not meet it again and there is no danger we will add it twice - if elem1 is bigger -> advance iter2, because there is a change that we meet elem1 duplicate is list2 later 6. Iterate through res  | Content Cell  | Feb, 14 |
| 3.6 | Josephus Problem (remove with skips)  | 1. Create a Doubly Linked List <br />2. Start with head, iterate while only one element is left <br />3. skip specified number of times <br />4. If while skipping we reach a tail, then we start from the head.next <br />5. Delete element -> reassign next/prev 6. When only one element is left, then return head.next  | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/JosephusIterableList.java)  | Feb, 15 |
| 3.9/3.10  | Collections addAll() and removeAll()  | 1. Given iterable items list, get the iterator and add while hasNext() / <br />1. Given iterable items list, get the iterator and check everything in the specified collection <br />2. Get the iterator for original list and iterate through it to check if this elements exists there too. If yes, remove it from the original collection.  | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/ArrayListTest.java)| Feb, 15 |
| 3.11 | Singly Linked List with a <br /> head node only  | 1. Initilize head <br />2. Initialize head.next <br />3. Contains: iter with while and check <br />4. add: check if contains, if not, create p and p.next = head.next; head.next = p; add in the middle <br />5. remove: check if contains. <br />**Do tracing** node and current node. When found node to remove -> prev.next = current.next  | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/SLL_headeronly.java)  | Feb, 16  |
| 3.12 | Repeat Exercise 3.11, maintaining the singly linked list in **sorted order**.  | Same as 3.11, but (4) add function changed to: <br /> 4. To keep sorted , check if it is more than header.next.  <br />* If yes, insert as usual: p.next = header.next; header.next = p; <br />* If no, start iterating from header to end, while remembering the previous node until we find a node which is more than one we want to insert.<br />* Make new node point to where previous node pointed. <br />* Make previous node point to new node. | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/SLL_headeronly_sorted.java) | Feb, 18 |
| 3.13 | Add support for a ListIterator to the MyArrayList class. Write a listIterator method to return a newly constructed ListIterator, and further, that the existing iterator method can return a newly constructed ListIterator. Thus you will change ArrayListIterator so that it implements ListIterator instead of Iterator. Throw an UnsupportedOperationException for methods not listed in Section 3.3.5.  | 1. Create private class withing MyArrayList names ArrayListIterator and make it implement ListIterator interface.<br /> 2. Complete given methods using current, ArrayList and functions in array list OR throw UnsupportedOperationException.<br />3. Add, so that listIterator method to returns a newly constructed ListIterator. Further, the existing iterator method can return a newly constructed ListIterator: ```public java.util.Iterator<AnyType> iterator() {return new ArrayListIterator();} public java.util.ListIterator<AnyType> listIterator() { return new ArrayListIterator();} ``` | [Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/MyArrayList.java) | Feb, 18 |
| 3.16 | An alternative to providing a ListIterator is to provide a method with signature Iterator<AnyType> reverseIterator(). <br />Then you could print a MyArrayList L in reverse by using the code ```Iterator<AnyType> ritr = L.reverseIterator( ); while( ritr.hasNext())  System.out.println( ritr.next( ) ); ```<br />Implement an ArrayListReverseIterator class, with this logic, and have reverseIterator return a newly constructed ArrayListReverseIterator.  | 1. Returns an Iterator, initialized to the last item, and for which next and hasNext are implemented to be <br />consistent with the iterator advancing toward the front of the list, rather than the back. <br />2. Start current with the last item and iterate whole current>0. Utilize ArrayList remove method that uses index to remove item. |[Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/MyArrayList.java)  <br />*private class ArrayListReverseIterator<AnyType> here* | Feb, 19 |
| 3.20 | Deletion Strategy: **Lazy deletion**. To delete an element, mark it deleted (using an extra bit field). The number of deleted and nondeleted elements in the list is kept as part of the data structure. If there are as many deleted elements as nondeleted elements, we traverse the entire list, performing the standard deletion algorithm on all marked nodes. | 1. Add Market field (true for deleted, false for non deleted). 2. Add Find function which deleted the node with a specified data. 3. Add Lazy Deletion functions which finds the node to delete and marks it deleted. 4. Add Delete() function, which traverses the list and deleted the nodes that are marked to be deleted. |[Solution](https://github.com/ayazhankadessova/LeetCode_Practice/blob/main/DSA_Book/Chapter3Exercises/src/LinkedList_LazyDeletion.java)  <br /> | Feb, 20 |




